library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;

entity ALU_1 is
port(Clock:in std_logic; --input clock signal
A,B : in unsigned(7 downto 0); --8 bit inputs from latches A and B
OP : in unsigned(15 downto 0); --16 bit selector for operation from decode
Neg : out std_logic; -- is the result negative? Set-ve bit output
R1: out unsigned(3 downto 0); --lower 4-bits of 8-bit result output
R2: out unsigned(3 downto 0)); --higher 4-bits of 8-bit result output
end ALU_1;

architecture calculation of ALU_1 is 
signal Reg1,Reg2,Result: unsigned(7 downto 0) :=(others=> '0'); --temp signal declarations
signal Reg4: unsigned(0 to 7); 
begin
Reg1 <= A; --temporarily store A in Reg1 local variable
Reg2 <= B; --temporarily store B in Reg2 local variable
process(Clock,OP)
	begin	
	if(rising_edge(Clock)) THEN 
		case OP is
		   
			WHEN "0000000000000001" => 
				Result <= Reg1 + Reg2; --addition
				Neg <= '0';

			WHEN "0000000000000010" => --subtraction	
				if (Reg1 >= Reg2) then
					Result <= Reg1 - Reg2; --if value is a negative number, the NOT Reg2+1 is converting to 2's complement
					Neg <='0';
				elsif (Reg2 > Reg1) then
					Result <= Reg2 + (NOT Reg1 + 1); --2's complement
			      Neg <='1';
				end if;
					
			WHEN "0000000000000100" => 
				Result <= NOT Reg1; --complement A (invert A)
				Neg <= '0';
										

			WHEN "0000000000001000" => 
				Result <= NOT (Reg1 AND Reg2); --NAND 
				Neg <= '0';
											
			WHEN "0000000000010000" => 
				Result <= NOT (Reg1 OR Reg2); --NOR
				Neg<='0';
												
	
			WHEN "0000000000100000" => 
				Result <= Reg1 AND Reg2; --AND
				Neg<='0';
											
			WHEN "0000000001000000" => 
				Result <= Reg1 XOR Reg2; --XOR
				Neg<='0';

			WHEN "0000000010000000" => 
				Result <= Reg1 OR Reg2; --OR
				Neg<='0';
			
			WHEN "0000000100000000" => 
				Result <= Reg1 XNOR Reg2; --XOR
				Neg<='0';
				
			WHEN OTHERS => 
			--don't care, do nothing
			
			
			end case;
		end if;
	end process;
	
R1 <= Result(3 downto 0); --since the output seven segments can
R2 <= Result(7 downto 4);--only 4-bits, split the 8-bit into 2 4-bits
end calculation;
